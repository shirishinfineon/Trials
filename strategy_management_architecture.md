# Strategy Management Architecture

This document outlines the architecture for defining, loading, selecting, combining, and parameterizing trading strategies within the algorithmic trading system. The `Strategy Engine` is the primary module responsible for managing strategies.

## 1. Strategy Definition

Strategies are the core logic units that make trading decisions. A clear and consistent definition is crucial.

*   **Base Class/Interface:**
    *   A common base class, say `BaseStrategy`, will be defined. All concrete strategies must inherit from this class.
    *   This base class can provide common helper functions, default behaviors, and enforce the implementation of required methods.
    *   Alternatively, an interface (e.g., `IStrategy` in Python using `abc.ABC`) could define the contract.

*   **Key Methods a Strategy Must Implement:**
    *   `__init__(self, strategy_id, params)`: Constructor to initialize the strategy with a unique ID and its parameters.
    *   `initialize(self, historical_data_service)`: Called once before trading starts. Used for one-time setup, e.g., pre-calculating indicators on historical data, warming up.
        *   `historical_data_service`: An object allowing access to historical data via the Data Handler.
    *   `on_market_data(self, market_data_event)`: Called whenever new market data (e.g., a new bar or tick) is available for a subscribed instrument. This is the primary method where strategy logic resides to analyze data and generate signals.
        *   `market_data_event`: An object containing the latest market data.
    *   `on_signal_confirmation(self, signal_id, execution_report)`: (Optional) Called when a signal generated by this strategy results in an order execution update.
    *   `on_parameters_updated(self, new_params)`: (Optional) Called if parameters are updated dynamically during runtime.
    *   `get_required_instruments(self)`: Returns a list of instruments this strategy needs market data for.

*   **Strategy Parameters Handling:**
    *   Parameters are specific settings that control a strategy's behavior (e.g., moving average periods, RSI thresholds, stop-loss percentages).
    *   Each strategy will define its required parameters.
    *   Parameters will be passed to the strategy instance during its `__init__` method, typically as a dictionary or a dedicated parameter object.
    *   The `BaseStrategy` can provide a mechanism to store and access these parameters.

## 2. Strategy Loading and Selection

The `Strategy Engine` is responsible for discovering, loading, and selecting strategies.

*   **Strategy Discovery and Loading:**
    *   **Directory-based Loading:** Strategies can be placed as Python modules/classes in a predefined directory (e.g., `/strategies`). The `Strategy Engine` would scan this directory, import modules, and identify classes that inherit from `BaseStrategy`.
    *   **Configuration File Listing:** A configuration file (managed by `Configuration Manager`) can explicitly list the strategies to be loaded, including their module path and class name. This provides more control.
        ```yaml
        # Example: strategies.yaml
        strategies_to_load:
          - module: strategies.moving_average_cross
            class: MovingAverageCrossStrategy
            id: MACross_EURUSD
            params:
              short_window: 10
              long_window: 30
          - module: strategies.rsi_oversold
            class: RSIOversoldStrategy
            id: RSI_BTCUSD
            params:
              rsi_period: 14
              oversold_threshold: 30
        ```
    *   The `Strategy Engine` would instantiate the strategy classes based on this configuration.

*   **Mechanism for Selecting Strategies to Run:**
    *   The primary mechanism for selecting which strategies to run for a particular session (backtest or live trading) will be through the main application configuration file.
    *   The configuration will specify which of the loaded/available strategies are "active" for the current run.
    *   Each active strategy instance will have a unique `strategy_id` and its specific parameters.

## 3. Strategy Combination (Conceptual)

Users may want to combine signals or insights from multiple strategies. Here are some conceptual approaches:

*   **Signal Aggregation/Voting:**
    *   Multiple independent strategies run concurrently.
    *   A "Meta-Strategy" or a dedicated component within the `Strategy Engine` collects signals from these individual strategies.
    *   **Voting:** If multiple strategies signal in the same direction for the same instrument, confidence in the trade increases. A threshold (e.g., 2 out of 3 strategies agree) could trigger a combined signal.
    *   **Weighted Voting:** Signals from different strategies could be weighted based on their historical performance or perceived reliability.
    *   **Consensus:** Only act if all (or a supermajority) of strategies agree.
    *   The `Meta-Strategy` would then generate a final signal to the `Execution Engine`.

*   **Master-Slave / Signal Filtering:**
    *   One "master" strategy generates primary signals.
    *   Other "slave" or "filter" strategies provide contextual information or confirmation. For example, a trend-following master strategy might generate a buy signal, which is then validated by a volume-based filter strategy. The trade is only placed if both agree.

*   **Portfolio-Level Allocation:**
    *   Instead of combining signals at the trade level, allocate capital to different strategies. Each strategy manages its allocated portion of the portfolio independently.
    *   The `Portfolio Manager` would track performance per strategy.
    *   This is less about combining signals and more about diversifying across strategies.

*   **Implementation Notes:**
    *   Combining strategies adds complexity. The initial implementation might focus on running multiple strategies independently, with combination features added later.
    *   If combination is implemented, the `Strategy Engine` would need clear rules on how signals are merged or prioritized.
    *   The `SignalEvent` structure might need fields to indicate its origin strategy and potentially confidence scores.

## 4. Parameterization from Configuration

Strategy-specific parameters are crucial for tuning and adapting strategies.

*   **Source of Parameters:**
    *   Parameters will be defined in a configuration file (e.g., YAML, JSON).
    *   As per the user query, these parameters could *originate* from an Excel sheet, which is then converted or exported into the system's configuration format. The system itself will not directly read Excel files for runtime configuration to avoid direct dependencies on Excel libraries in the core trading logic and for better version control of configurations. A separate script or process can handle the Excel-to-config-format conversion.

*   **Flow of Parameters:**
    1.  **User/Excel:** User defines parameters in an Excel sheet (optional).
    2.  **Conversion (if Excel is used):** A script converts the Excel data into a structured configuration file (e.g., YAML).
    3.  **Configuration File:** This file contains a list of active strategies, their unique IDs, and their specific parameter sets.
        ```yaml
        # Example: main_config.yaml
        active_strategies:
          - strategy_id: MACross_EURUSD_Live
            module: strategies.moving_average_cross
            class: MovingAverageCrossStrategy
            params:
              instrument: EUR/USD
              short_window: 10
              long_window: 30
              stop_loss_pct: 0.02
          - strategy_id: RSI_BTCUSD_Paper
            module: strategies.rsi_oversold
            class: RSIOversoldStrategy
            params:
              instrument: BTC/USD
              rsi_period: 14
              oversold_threshold: 30
              take_profit_pct: 0.05
        ```
    4.  **Configuration Manager:** The `Configuration Manager` loads this main configuration file.
    5.  **Strategy Engine:** The `Strategy Engine`, during its initialization, requests the list of active strategies and their parameters from the `Configuration Manager`.
    6.  **Strategy Instantiation:** For each active strategy entry, the `Strategy Engine` dynamically loads the specified module and class, then instantiates it by passing the `strategy_id` and the `params` dictionary to its constructor.
        ```python
        # Pseudocode in StrategyEngine
        # active_strategies_config = config_manager.get_active_strategies()
        # for config in active_strategies_config:
        #   module = importlib.import_module(config['module'])
        #   StrategyClass = getattr(module, config['class'])
        #   strategy_instance = StrategyClass(strategy_id=config['strategy_id'], params=config['params'])
        #   self.strategies.append(strategy_instance)
        ```

This architecture provides a flexible way to define, manage, and parameterize trading strategies, allowing for both simple and potentially more complex multi-strategy setups.
